name: 'Stale branch and issue management'

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
  pull_request:
    types: [opened, edited, synchronize]
  issues:
    types: [opened, edited]

jobs:
  stale-issues:
    runs-on: ubuntu-latest
    if: github.repository == 'yeongseon/azure-functions-openapi'
    
    steps:
      - name: 'Stale issues and PRs'
        uses: actions/stale@v9
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          stale-issue-message: 'This issue has been marked as stale because it has not had recent activity. It will be closed in 7 days if no further activity occurs. Please reopen if this is still relevant.'
          stale-pr-message: 'This pull request has been marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Please reopen if this is still relevant.'
          stale-issue-label: 'stale'
          stale-pr-label: 'stale'
          exempt-issue-labels: 'pinned,security,enhancement,bug,documentation'
          exempt-pr-labels: 'pinned,security,enhancement,bug,documentation,wip'
          days-before-stale: 60
          days-before-close: 7
          close-issue: true
          close-pr: false

  stale-branches:
    runs-on: ubuntu-latest
    if: github.repository == 'yeongseon/azure-functions-openapi'
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 'Delete stale branches'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 90);
            
            const { data: branches } = await github.rest.repos.listBranches({
              owner,
              repo,
              per_page: 100
            });
            
            const { data: closedPullRequests } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'closed',
              base: 'main',
              per_page: 100
            });

            const mergedBranches = new Map();
            closedPullRequests.forEach(pr => {
              if (pr.merged_at && pr.head && pr.head.ref && pr.head.repo?.full_name === `${owner}/${repo}`) {
                mergedBranches.set(pr.head.ref, new Date(pr.merged_at));
              }
            });
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            const branchesToKeep = new Set(['main']);
            
            pullRequests.forEach(pr => {
              if (pr.head.ref) {
                branchesToKeep.add(pr.head.ref);
              }
            });
            
            for (const branch of branches) {
              if (branchesToKeep.has(branch.name)) {
                continue;
              }
              
              const { data: branchCommit } = await github.rest.repos.getCommit({
                owner,
                repo,
                ref: branch.commit.sha
              });
              const branchDate = new Date(branchCommit.commit.committer.date);
              if (branchDate < cutoffDate && branch.name !== 'main') {
                console.log(`Checking stale branch for deletion: ${branch.name} (last updated: ${branchDate.toISOString()})`);
                
                try {
                  const { data: protectedBranch } = await github.rest.repos.getBranchProtection({
                    owner,
                    repo,
                    branch: branch.name
                  });
                  console.log(`Branch ${branch.name} is protected, skipping deletion`);
                  continue;
                } catch (error) {
                  if (error.status === 404) {
                    console.log(`Branch ${branch.name} is not protected, proceeding with deletion`);
                    
                    const mergedAt = mergedBranches.get(branch.name);
                    const isMergedStale = mergedAt && mergedAt < cutoffDate;
                    if (branch.name !== 'main' && !branchesToKeep.has(branch.name) && isMergedStale) {
                      console.log(`Deleting stale branch: ${branch.name}`);
                      await github.rest.git.deleteRef({
                        owner,
                        repo,
                        ref: `heads/${branch.name}`
                      });
                    }
                  }
                }
              }
            }

  branch-naming-validation:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: 'Validate branch naming convention'
        id: validate-branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = context.payload.pull_request.head.ref;
            const validPatterns = [
              /^feat\/.+$/,
              /^fix\/.+$/,
              /^docs\/.+$/,
              /^chore\/.+$/,
              /^ci\/.+$/,
              /^main$/
            ];
            
            const isValid = validPatterns.some(pattern => pattern.test(branchName));
            core.setOutput('isValid', String(isValid));
            
            if (!isValid) {
              core.setFailed(`Invalid branch name: ${branchName}. Please use one of the following naming conventions:
                - feat/<description>
                - fix/<description>
                - docs/<description>
                - chore/<description>
                - ci/<description>
                - main`);
            } else {
              core.info(`Branch name validation passed: ${branchName}`);
            }
            
            return { isValid };

      - name: 'Add comment with validation result'
        if: steps.validate-branch.outputs.isValid == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const branchName = context.payload.pull_request.head.ref;
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: '⚠️ Branch naming validation failed\n\nYour branch name `' + branchName + '` does not follow our naming conventions.\n\nPlease rename your branch to follow one of these patterns:\n- `feat/<description>` for new features\n- `fix/<description>` for bug fixes  \n- `docs/<description>` for documentation changes\n- `chore/<description>` for maintenance tasks\n- `ci/<description>` for CI/CD changes\n\nTo rename your branch:\n1. `git checkout ' + branchName + '`\n2. `git branch -m feat/your-new-branch-name`\n3. `git push origin --delete ' + branchName + '`\n4. `git push origin feat/your-new-branch-name`\n\nOnce you\\'ve renamed the branch, please update the PR head branch.'
            });
